import {Socket} from 'socket.io-client';
import useListener from './useListener';

export default class Link {
    public id: string | null = null;

    private _pairListener = useListener()

    private readonly _socket: Socket;

    constructor(socket: Socket) {
        this._socket = socket
        this._socket.on('paapi:paired', this._pairListener.trigger)
    }

    /**
     * Wait for a specific event in the socket
     * @param event
     */
    public waitFor(event: string): any {
        return new Promise(resolve => {
            this._socket.once(event, data => {
                resolve(data)
            })
        })
    }

    /**
     * Start pairing with an existing device or create a room to pair in
     * @param id: The id to pair with. If not provided, an ID will be generated by the server
     */
    async pair(id: string | null): Promise<Link> {
        if (!this.connected) {
            await this.waitFor('connect')
        }
        this._socket.emit('paapi:join', id)
        this.id = await this.waitFor('paapi:joined') as string
        return this
    }

    /**
     * Add a listener for when the link has been paired
     * @param listener
     */
    public onPair(listener: Function) {
        this._pairListener.bind(listener)
    }

    /**
     * If the Link has been paired
     */
    get paired(): boolean {
        // If the link hasn't a id, it's not paired
        return this.id !== null
    }

    /**
     * ===== Socket io pass through =====
     */
    get socket(): Socket {
        return this._socket
    }

    get connected(): boolean {
        return this._socket.connected
    }
    get disconnected(): boolean {
        return this._socket.disconnected
    }
    send(eventName: string, ...args: any[]): Socket {
        return this._socket.send(eventName, ...args)
    }
    emit(eventName: string, ...args: any[]): Socket {
        return this._socket.emit(eventName, ...args)
    }
    on(eventName: string, callback: (...args: any[]) => void): Socket {
        return this._socket.on(eventName, callback)
    }
    onAny(callback: (event: string,...args: any[]) => void): Socket {
        return this._socket.onAny(callback)
    }
    prependAny(callback: (event: string,...args: any[]) => void): Socket {
        return this._socket.prependAny(callback)
    }
    offAny(callback: (event: string,...args: any[]) => void): Socket {
        return this._socket.offAny(callback)
    }
    once(eventName: string, callback: (...args: any[]) => void): Socket {
        return this._socket.once(eventName, callback)
    }
    listeners(eventName: string): Function[] {
        return this._socket.listeners(eventName)
    }
    listenersAny(): Function[] {
        return this._socket.listenersAny()
    }
    off(eventName: string, listener: (...args: any[]) => void): Socket {
        return this._socket.off(eventName, listener)
    }
    compress(value: boolean): Socket {
        return this._socket.compress(value)
    }
    timeout(value: number): Socket {
        return this._socket.timeout(value)
    }
    connect(): Socket {
        return this._socket.connect()
    }
    open(): Socket {
        return this._socket.open()
    }
    close(): Socket {
        return this._socket.close()
    }
    disconnect(): Socket {
        return this._socket.disconnect()
    }
    get volatile(): Socket {
        return this._socket.volatile
    }
}
